<!--
@license
Copyright (c) 2018 Foundation For an Innovative Future (InnovativeFuture.org)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or any
later version.

Foundation For an Innovative Future reserves the right to release the
covered work, in part or in whole, under a different open source
license and/or with specific copyleft exclusions.  Such a release
would not invalidate the license for this project, although the
project released with a modified license would not be considered
part of this covered work or subject to the copyleft portions of this
license even if the projects are identical.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Please email contact@innovativeFuture.org for inquiries related to
this license.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="ctree-data-loader.html">
<link rel="import" href="ctree-loader-behavior-xapi.html">

<script>
(function() {

  'use strict';

  CTree.DataLoader = class extends CTree.DataLoaderMixin(CTree.LoaderBehavior) {
    static get properties() {
      return {
      };
    }

    /**
     * Gets the cTree data based on the given params and calls onComplete({key: Object}).
     *
     * @param {String}                cTreeKey    Key of tree to get the data for
     * @param {Object}                params      Key-value pairs of all parameters
     * @param {Function(key: Object)} onComplete  Function to call with loaded data, or null if failed
     */
    _getCTreeData(cTreeKey, params, onComplete) {
      params.cTree = cTreeKey;
      CTree.Loader.getData(params, data => {
        if (!data || !data.cTrees) { // TODO: change from data.cTrees to data.cTree to match spec
          console.error('Error: unable to load valid cTree data');
          onComplete(null);
        } else {
          // TODO: uncomment to match spec (currently, uses key 'cTree' instead of 'id')
          //onComplete(CTree.Loader.getFromArrayWithId(data.cTree, cTreeKey, false));
          onComplete(data.cTrees[0]);
        }
      });
    }

    /**
     * Gets the data for the item with the given type, ID, and params and calls onComplete({key: Object}).
     *
     * @param {String}                cTreeKey    Key of tree to get the data for
     * @param {Object}                params      Key-value pairs of all parameters
     * @param {Function(key: Object)} onComplete  Function to call with loaded data, or null if failed
     */
    _getItemDataByType(cTreeKey, typeName, typeId, params, onComplete) {
      params[typeName] = typeId;
      _getCTreeData(cTreeKey, params, cTreeData => {
        if (!cTreeData || !cTreeData[typeName]) {
          console.error('Error: unable to load valid ' + typeName + ' data with id=' + typeId);
          onComplete(null);
        } else {
          onComplete(CTree.Loader.getFromArrayWithId(cTreeData[typeName], typeId, false));
        }
      });
    }

    /**
     * Load the human readable name associated with the cTree
     *
     * @param {String} ctreeKey Key for cTree to load name for
     * @param {Function(String)} onComplete Function called when completed, with the cTree name if successful, otherwise null
     */
    _loadName(cTreeKey, onComplete) {
       this._getCTreeData(cTreeKey, {
         cTreeName: true,
       }, data => {
         if (!data) {
           console.error('Error: unable to load cTree name: no valid data');
           onComplete(null);
         } else {
           onComplete(data.cTreeName);
         }
       });
    }

    /**
     * Load the element types associated with the cTree
     *
     * @param {String} cTreeKey Key for cTree to load element types for
     * @param {Function(Types)} onComplete Function called when completed, with the element types if successful, otherwise null. Types may be an array or object with types indexed by ID.
     */
    _loadTypes(cTreeKey, onComplete) {
      this._getCTreeData(cTreeKey, {
        postType: null, // 'id'
      }, data => {
        if (!data) {
          console.error('Error: unable to load post types: no valid data');
          onComplete(null);
        } else {
          onComplete(data.postType);
        }
      });
    }

    /**
     * Load the segment types associated with the cTree
     *
     * @param {String} cTreeKey Key for cTree to load segment types for
     * @param {Function(SegmentTypes)} onComplete Function called when completed, with the segment types if successful, otherwise null. Types may be an array or object with segment types indexed by ID.
     */
    _loadSegmentTypes(cTreeKey, onComplete) {
      this._getCTreeData(cTreeKey, {
        segmentType: null, // 'id'
      }, data => {
        if (!data) {
          console.error('Error: unable to load segment types: no valid data');
          onComplete(null);
        } else {
          onComplete(data.segmentType);
        }
      });
    }

    /**
     * Load element data for the provided element ID.  Once complete, onLoadingComplete will be
     * called with the final, fully loaded item.
     *
     * Element Structure:
     *   {
     *     id: String,
     *     type: String,
     *     title: String,
     *     parents: [Strings],              // TODO: later
     *     children: [Strings],             // TODO: later
     *     childrenSearchComplete: Boolean, // TODO: later
     *     designer: String,                // TODO: later
     *     description: [Descriptions],
     *     feedback: [Feedback],            // TODO: later
     *     bookmarked: Boolean,             // TODO: later
     *   }
     *
     * @param {String} elementId                  ID of the element to load data for.
     * @param {Function(Element)} onComplete      (Optional) Function called when loading the description and all segments has been completed. This is passed the loaded element as a parameter. If no matching element is found or the request fails this will be called with null data.
     * @param {String} descriptionId              (Optional) ID of the description you want to load.
     * @param {Array}  segmentVariations          (Optional) Array of IDs with a variation for each segment to be loaded. The corresponding descriptionId must also be specified.
     * @param {Number} descriptionVariationsCount (Optional) Total number of description variations to load. Only the first should be loaded fully, with all others loaded without any segments. This may be specified even if descriptionId isn't provided.
     * @param {Number} segmentVariationsCount     (Optional) Total number of variations to load for each segment. This may be specified even if segmentVariations isn't provided.
     */
    _loadElement(elementId, onComplete, descriptionId, segmentVariations, descriptionVariationsCount, segmentVariationsCount) {
      var params = {};
      if (descriptionId != null) params.descriptionData = descriptionId;
      if (segmentVariations != null && segmentVariations.length > 0) {
        var segmentVariationStr = '';
        segmentVariations.forEach(variationId => {
          if (segmentVariationStr.length > 0) segmentVariationStr += ',';
          segmentVariationStr += variationId;
        });
        params.segmentVariationData = segmentVariationStr;
      }
      if (descriptionVariationsCount != null) params.descriptionPageSize = descriptionVariationsCount;
      if (segmentVariationsCount != null) params.segmentVariationPageSize = segmentVariationsCount;
      _getItemDataByType(this.cTreeKey, 'post', elementId, params, elementData => {
        /**
         * TODO: Store the element to the local element cache. If an entry already
         * exists, update it as needed.
         */
        onComplete(elementData)
      });
    }

    /**
     * Load description data for the provided description ID, including segment
     * variations for the description. Once complete, onComplete will be called
     * with the final, fully loaded description.
     *
     * Description Structure:
     *   {
     *     id: String,
     *     contributors: [String],  // TODO: later
     *     segments: [Segments],
     *   }
     * Segment Structure:
     *   {
     *     id: String,
     *     type: String,  // not required for descriptions where no segment variations have been loaded
     *     variations: [SegmentVariations],
     *   }
     *
     * @param {String} descriptionId          ID of the description you want to load.
     * @param {Function(Description)} onComplete Function called when loading the description and all segments has been completed. This is passed the loaded description as a parameter. If no description is found with a matching ID or the request fails this will be called with null data.
     * @param {Array}  segmentVariations      (Optional) Array of IDs with a variation for each segment to be loaded.
     * @param {Number} segmentVariationsCount (Optional) Total number of variations to load for each segment. This may be specified even if segmentVariations isn't provided.
     */
    _loadDescription(descriptionId, onComplete, segmentVariations, segmentVariationsCount) {
      var params = {};
      if (segmentVariations != null && segmentVariations.length > 0) {
        var segmentVariationStr = '';
        segmentVariations.forEach(variationId => {
          if (segmentVariationStr.length > 0) segmentVariationStr += ',';
          segmentVariationStr += variationId;
        });
        params.segmentVariationData = segmentVariationStr;
      }
      if (segmentVariationsCount != null) params.segmentVariationPageSize = segmentVariationsCount;
      _getItemDataByType(this.cTreeKey, 'description', descriptionId, params, descriptionData => {
        onComplete(descriptionData)
      });
    }

    /**
     * Load the specified number of additional description variations for the
     * provided element and call onComplete with them. These are shallow
     * description variations and do not include the segment variations, which
     * would need to be loaded separately.
     *
     * @param {Element} element The element to load the description variations for.
     * @param {Number}  count   The number of additional description variations to load.
     * @param {Function(Descriptions[])} onComplete Function called when loading the description variations has completed. It's passed an array of all loaded descriptions, if there were any. If the request fails this will be called with null data.
     */
    _loadDescriptionVariations(element, count, onComplete) {
      _getCTreeData(this.cTreeKey, {
        description: null,  // 'rating'
        forPost: element.id,
        pageOffset: element._descriptionOffset,
        descriptionPageSize: count,
        segmentVariationPageSize: 0,
      }, cTreeData => {
        if (!cTreeData || !cTreeData.description) {
          console.error('Error: unable to load valid description variations for element with id=' + element.id);
          onComplete(null);
        } else {
          var descriptionVariationData = cTreeData.forElement[element.id];
          element._descriptionOffset = descriptionVariationData.descriptionNextPageOffset;
          onComplete(descriptionVariationData.description);
        }
      });
    }

    /**
     * Load segment variation data for the provided segment ID. Once complete,
     * onComplete will be called with the result.
     *
     * SegmentVariation Structure:
     *   {
     *     id: String,
     *     type: String,
     *     data: dynamic,	// data type depends on segment type
     *   }
     *
     * @param {String} segmentVariationId ID of the segment variation you want to load.
     * @param {Function(SegmentVariation)} onComplete  (Optional) Function called when loading the segmentvariation has been completed.  This is passed the resulting segment variation item, or null if none is found with the expected type.
     */
    _loadSegmentVariation(segmentVariationId, onComplete) {
      _getItemDataByType(this.cTreeKey, 'segmentVariation', segmentVariationId, {}, segmentVariationData => {
        onComplete(segmentVariationData)
      });
    }

    /**
     * Load the specified number of additional segment variations for the
     * provided segments and call onComplete with an array of segment variations
     * matching the size of the provided array of segments.
     *
     * @param {[Segments]} description The segments to load the variations for.
     * @param {Number}     count       The number of additional variations to load for each segment.
     * @param {Function(SegmentVariations[])} onComplete Function called when loading the description variations has completed. It's passed an array of all loaded descriptions, if there were any. If the request fails this will be called with null data.
     */
    _loadSegmentVariations(segments, count, onComplete) {
      var segmentsStr = '';
      var offsetsStr = '';
      segments.forEach(segment => {
        if (segmentsStr.length > 0) {
          segmentsStr += ',';
          offsetsStr += ',';
        }
        segmentsStr += segment.id;
        offsetsStr += segment._variationsOffset;
      });
      _getCTreeData(this.cTreeKey, {
        segmentVariation: null,  // 'rating'
        forSegment: segmentsStr,
        pageOffset: offsetsStr,
        segmentVariationPageSize: count,
      }, cTreeData => {
        if (!cTreeData || !cTreeData.segmentVariation) {
          console.error('Error: unable to load valid segment variations for segment with ids=[' + segmentsStr + ']');
          onComplete(null);
        } else {
          var segmentVariationsArray = [];
          for (var i = 0; i < segments.length; i++) {
            var segment = segments[i];
            var segmentVariations = cTreeData.forSegment[segment.id];
            segment._variationsOffset = segmentVariations.segmentVariationNextPageOffset;
            segmentVariationsArray[i] = segmentVariations.segmentVariation;
          }
          onComplete(segmentVariationsArray);
        }
      });
    }
  };

})();

</script>
